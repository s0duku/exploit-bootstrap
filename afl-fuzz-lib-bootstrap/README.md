
# Fuzz shared library function with afl++ qemu-mode

# Intro
* https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.persistent.md
  
Bootstrap to use afl++ qemu-mode to fuzz binary shared library.

# Attention

* If you want to use protobuf with x86 harness, things be come kind of trouble, need to do more work on Makfile.
* Using protobuf fuzz can be more complex, at least make sure normal fuzz works ok, then trying to set protobuf fuzz.


# Steps

* put your target library under the target directory
* lib , put other libraries that target library depend
* harness.c , modify the harness code to adjust your fuzz target
* Makefile , modify the Makefile code to adjust your fuzz target, variable FUZZ_LIB_NAME, FUZZ_LIB_FUNC_NAME
* make test , test harness works ok
* make fuzz , run afl-fuzz
* make clean , clean the output and build


# Command
* make clean
* make trace TRACE_INPUT_CASE=./inputs/seeds


# Notes

The start of the persistent loop has to be set with environment 
* AFL_QEMU_PERSISTENT_ADDR The START address
* * the start of persistent loop, can be any instruction address, defined with the 0x prefix hexdecimal value or decimal value
* * if the target is compiled with PIE/PIC, qemu loads to a specific address. For 64 bit you have to add 0x4000000000 (9 zeroes) and for 32 bit 0x40000000 (7 zeroes) to the address.You can check it printing the process map using AFL_QEMU_DEBUG_MAPS=1 afl-qemu-trace TARGET-BINARY.
* * If this address is not valid, afl-fuzz will error during startup with the message that the forkserver was not found.
* AFL_QEMU_PERSISTENT_RET The RET address
* * The RET address is the last instruction of the persistent loop. The emulator will emit a jump to START when translating the instruction at RET. It is optional and only needed if the return should not be at the end of the function to which the START address points into, but earlier.It is defined by setting AFL_QEMU_PERSISTENT_RET, and too 0x4000000000 has to be set if the target is position independent.
* AFL_QEMU_PERSISTENT_RETADDR_OFFSET
* * This option is valid only for x86/x86_64 only, arm/aarch64 do not save the return address on stack.If the START address is not the beginning of a function, and no RET has been set (so the end of the loop will be at the end of the function but START will not be at the beginning of it), we need an offset from the ESP pointer to locate the return address to patch.
* AFL_QEMU_PERSISTENT_GPR=1
* * It is very, very likely you need to restore the general purpose registers state when starting a new loop. Because of this 99% of the time you should set. for example main function's arguments, If you don't save and restore the registers in x86_64, the parameter argc will be lost at the second execution of the loop.
* AFL_QEMU_SNAPSHOT
* * AFL_QEMU_SNAPSHOT=address is just a "syntactical sugar" environment variable that is equivalent to the following set of variables: AFL_QEMU_PERSISTENT_ADDR=address, AFL_QEMU_PERSISTENT_GPR=1, AFL_QEMU_PERSISTENT_MEM=1, AFL_QEMU_PERSISTENT_EXITS=1
* AFL_QEMU_INST_RANGES
* * AFL_QEMU_INST_RANGES=A,B,C... can tell QEMU to instrument only a part of the address space.The format of the items in the list is either a range of addresses like 0x123-0x321 or a module name like module.so (that is matched in the mapped object filename).Setting AFL_INST_LIBS=1 can be used to circumvent the .text detection logic and instrument every basic block encountered.




