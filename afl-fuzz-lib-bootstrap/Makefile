

# https://github.com/AFLplusplus/AFLplusplus/blob/stable/docs/env_variables.md
# https://github.com/AFLplusplus/AFLplusplus/tree/stable/utils/persistent_mode
# https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.md


CC = clang-14
CXX = clang++-14

# user need to set target library, and target fuzz function, and buf size use to read data
FUZZ_LIB_NAME = libvuln.so
FUZZ_LIB_FUNC_NAME = vuln_func
FUZZ_INPUT_BUF_SIZE = 0x100000

FUZZ_ARCH = x64

FUZZ_LIB_LDPATH = $(shell pwd)/lib/$(FUZZ_ARCH):$(LD_LIBRARY_PATH)
FUZZ_LIB_PATH = $(shell pwd)/target/$(FUZZ_ARCH)/$(FUZZ_LIB_NAME)
FUZZ_QEMU_PATH = $(shell pwd)/qemu/$(FUZZ_ARCH)/afl-qemu-trace

# replace default qemu

_ = $(shell cp $(FUZZ_QEMU_PATH) $(shell which afl-qemu-trace))

FUZZ_LOG_PATH = '"/tmp/afl-fuzz-lib-bootstrap.log"'

ifeq ($(FUZZ_ARCH),x86)
	CFLAG_ARCH = -m32 -DFUZZ_ARCH_X86
endif
ifeq ($(FUZZ_ARCH),x64)
	CFLAG_ARCH = -m64 -DFUZZ_ARCH_X64
endif


CFLAGS = $(CFLAG_ARCH) -Wl,--no-as-needed -ldl -no-pie -DFUZZ_INPUT_BUF_SIZE=$(FUZZ_INPUT_BUF_SIZE) -DFUZZ_LOG_PATH=$(FUZZ_LOG_PATH)

HARNESS_SRC = harness.c
HARNESS = harness

HOOK_SRC = hook.c
HOOK = libhook.so

AFL_INPUTS = $(shell pwd)/inputs
AFL_OUTPUTS = $(shell pwd)/outputs
AFL_PRELOAD = $(shell pwd)/lib/$(FUZZ_ARCH)/$(HOOK)

# AFL_QEMU_PERSISTENT_ADDR = 0x4000000000
AFL_QEMU_PERSISTENT_CNT = 5000
AFL_QEMU_PERSISTENT_GPR = 1
AFL_QEMU_PERSISTENT_MEM = 1
AFL_QEMU_PERSISTENT_EXITS = 1
# AFL_QEMU_INST_RANGES = $(FUZZ_LIB_NAME)
AFL_INST_LIBS = 1




PROTOBUF_FUZZ_DATA_PROTO = protobuf_fuzz_data.proto
PROTOBUF_FUZZ_DATA_CPP = protobuf_fuzz_data.pb.cc
PROTOBUF_FUZZ_DATA_CH = protobuf_fuzz_data.pb.h

PROTOBUF_HELPER_PROTO_DIR = $(shell pwd)
PROTOBUF_HELPER_CPP_DIR = $(shell pwd)



# carefuly handle link problem, make sure header file, library version are match!


PROTOBUF_SRC_DIR = $(shell pwd)/libprotobuf-mutator-master/build/external.protobuf
PROTOBUF_CC = $(PROTOBUF_SRC_DIR)/bin/protoc-*
PROTOBUF_LIBRARY_PATH = $(shell pwd)/libprotobuf-mutator-master/build/external.protobuf/lib/libprotobufd.a
LPM_LIBRARY_PATH = $(shell pwd)/libprotobuf-mutator-master/build/src/libprotobuf-mutator.a
LPM_HEADER_PATH = $(shell pwd)/libprotobuf-mutator-master/src/mutator.h
LPM_SRC_DIR = $(shell pwd)/libprotobuf-mutator-master

PROTOBUF_HELPER_SRC = protobuf_helper.cc
PROTOBUF_HELPER_TEST_SRC = protobuf_helper_test.cc
PROTOBUF_HELPER = libprotobuf_helper.so
PROTOBUF_HELPER_TEST = protobuf_helper_test
PROTOBUF_HELPER_CFLAGS = -Wall --shared -fPIC -I$(PROTOBUF_SRC_DIR)/include -I$(LPM_SRC_DIR) -lz -Wl,--whole-archive $(LPM_LIBRARY_PATH) -Wl,--no-whole-archive -Wl,--whole-archive $(PROTOBUF_LIBRARY_PATH) -Wl,--no-whole-archive

AFL_DISABLE_TRIM=1
AFL_CUSTOM_MUTATOR_ONLY=1
AFL_CUSTOM_MUTATOR_LIBRARY=$(shell pwd)/$(PROTOBUF_HELPER)
AFL_SKIP_CPUFREQ=1


help: 
	@echo "Usage: make [OPTIONS]"
	@echo "  TARGETS:"
	@echo "    fuzz      Compile harness and run afl++."
	@echo "    clean     Clean all outputs"
	@echo "    help      Show this help."
	@echo "    test      Run harness tests."
	@echo "    start     Run afl++, but do not recompile harness."
	@echo "    gdb       Run harness with gdb."
	@echo "    dry       Run harness directly."
	@echo "    lpm       Compile libprotobuf-mutator module."
	@echo ""
	
# makefile every line fork a new shell, so env will not work
# fuzz target with afl, by default, use persistent mode
# direct read inputs from stdin
fuzz: hook compile
	@echo " "
	@export AFL_QEMU_PERSISTENT_CNT=$(AFL_QEMU_PERSISTENT_CNT); \
	export AFL_QEMU_PERSISTENT_ADDR=$(shell nm $(HARNESS) | grep 'T call_fuzz_func' | awk '{print"0x"$$1}'); \
	export AFL_QEMU_PERSISTENT_GPR=$(AFL_QEMU_PERSISTENT_GPR); \
	export AFL_QEMU_PERSISTENT_MEM=$(AFL_QEMU_PERSISTENT_MEM); \
	export AFL_QEMU_PERSISTENT_EXITS=$(AFL_QEMU_PERSISTENT_EXITS); \
	export AFL_PRELOAD=$(AFL_PRELOAD); \
	export AFL_INST_LIBS=$(AFL_INST_LIBS); \
	export LD_LIBRARY_PATH=$(FUZZ_LIB_LDPATH); \
	export FUZZ_LIB_PATH=$(FUZZ_LIB_PATH); \
	export FUZZ_LIB_FUNC_NAME=$(FUZZ_LIB_FUNC_NAME); \
	afl-fuzz -i $(AFL_INPUTS) -o $(AFL_OUTPUTS) -m none -Q -- `pwd`/$(HARNESS)
# 	export AFL_INST_LIBS=$(AFL_INST_LIBS); \
# directly call afl-fuzz again	
start: hook
	@echo " "
	@export AFL_QEMU_PERSISTENT_CNT=$(AFL_QEMU_PERSISTENT_CNT); \
	export AFL_QEMU_PERSISTENT_ADDR=$(shell nm $(HARNESS) | grep 'T call_fuzz_func' | awk '{print"0x"$$1}'); \
	export AFL_QEMU_PERSISTENT_GPR=$(AFL_QEMU_PERSISTENT_GPR); \
	export AFL_QEMU_PERSISTENT_MEM=$(AFL_QEMU_PERSISTENT_MEM); \
	export AFL_QEMU_PERSISTENT_EXITS=$(AFL_QEMU_PERSISTENT_EXITS); \
	export AFL_PRELOAD=$(AFL_PRELOAD); \
	export AFL_INST_LIBS=$(AFL_INST_LIBS); \
	export LD_LIBRARY_PATH=$(FUZZ_LIB_LDPATH); \
	export FUZZ_LIB_PATH=$(FUZZ_LIB_PATH); \
	export FUZZ_LIB_FUNC_NAME=$(FUZZ_LIB_FUNC_NAME); \
	afl-fuzz -i $(AFL_INPUTS) -o $(AFL_OUTPUTS) -m none -Q -- `pwd`/$(HARNESS)


protobuf_dry: $(PROTOBUF_HELPER) stub
	@echo " "
	@$(CC) $(CFLAGS) -DCALL_FUZZ_FUNC -DPROTOBUF_FUZZ $(PROTOBUF_HELPER) $(HARNESS_SRC) -o $(HARNESS)
	@export LD_LIBRARY_PATH=$(FUZZ_LIB_LDPATH):$(shell pwd); \
	export FUZZ_LIB_PATH=$(FUZZ_LIB_PATH); \
	export FUZZ_LIB_FUNC_NAME=$(FUZZ_LIB_FUNC_NAME); \
	./$(HARNESS)

protobuf_trace: $(PROTOBUF_HELPER) stub
	@if [ "$(TRACE_INPUT_CASE)" = "" ]; then\
		echo "Please Set TRACE_INPUT_CASE Env"; \
		exit 1;\
	fi
	@echo " "
	@$(CC) $(CFLAGS) -DCALL_FUZZ_FUNC -DPROTOBUF_FUZZ $(PROTOBUF_HELPER) $(HARNESS_SRC) -o $(HARNESS)
	@export LD_LIBRARY_PATH=$(FUZZ_LIB_LDPATH):$(shell pwd); \
	export FUZZ_LIB_PATH=$(FUZZ_LIB_PATH); \
	export FUZZ_LIB_FUNC_NAME=$(FUZZ_LIB_FUNC_NAME); \
	afl-qemu-trace $(HARNESS) < $(TRACE_INPUT_CASE)

protobuf_fuzz: hook $(PROTOBUF_HELPER) stub
	@echo " "
	@$(CC) $(CFLAGS) -DCALL_FUZZ_FUNC -DPROTOBUF_FUZZ $(PROTOBUF_HELPER) $(HARNESS_SRC) -o $(HARNESS)
	@export AFL_QEMU_PERSISTENT_CNT=$(AFL_QEMU_PERSISTENT_CNT); \
	export AFL_QEMU_PERSISTENT_ADDR=$(shell nm $(HARNESS) | grep 'T call_fuzz_func' | awk '{print"0x"$$1}'); \
	export AFL_QEMU_PERSISTENT_GPR=$(AFL_QEMU_PERSISTENT_GPR); \
	export AFL_QEMU_PERSISTENT_MEM=$(AFL_QEMU_PERSISTENT_MEM); \
	export AFL_QEMU_PERSISTENT_EXITS=$(AFL_QEMU_PERSISTENT_EXITS); \
	export AFL_DISABLE_TRIM=$(AFL_DISABLE_TRIM); \
	export AFL_CUSTOM_MUTATOR_ONLY=$(AFL_CUSTOM_MUTATOR_ONLY); \
	export AFL_CUSTOM_MUTATOR_LIBRARY=$(AFL_CUSTOM_MUTATOR_LIBRARY); \
	export AFL_SKIP_CPUFREQ=$(AFL_SKIP_CPUFREQ); \
	export AFL_PRELOAD=$(AFL_PRELOAD); \
	export AFL_INST_LIBS=$(AFL_INST_LIBS); \
	export LD_LIBRARY_PATH=$(FUZZ_LIB_LDPATH):$(shell pwd); \
	export FUZZ_LIB_PATH=$(FUZZ_LIB_PATH); \
	export FUZZ_LIB_FUNC_NAME=$(FUZZ_LIB_FUNC_NAME); \
	afl-fuzz -i $(AFL_INPUTS) -o $(AFL_OUTPUTS) -m none -Q -- `pwd`/$(HARNESS)



# buil protocol buffer fuzz data header file, cpp file
$(PROTOBUF_FUZZ_DATA_CPP): $(PROTOBUF_FUZZ_DATA_PROTO)
	$(PROTOBUF_CC) $(PROTOBUF_FUZZ_DATA_PROTO) -I=$(PROTOBUF_HELPER_PROTO_DIR) --cpp_out=$(PROTOBUF_HELPER_CPP_DIR)

# build protocl buffer afl mutator
$(PROTOBUF_HELPER): $(PROTOBUF_FUZZ_DATA_CPP) $(LPM_HEADER_PATH)
	$(CXX) $(PROTOBUF_HELPER_CFLAGS) $(PROTOBUF_FUZZ_DATA_CPP) $(PROTOBUF_HELPER_SRC) -o $(PROTOBUF_HELPER)
# test protobuf mutator

TEST_MUTATE_TIMES = 1000

# make test_protobuf_helper TEST_OPTION=w TEST_CASE=results
# make test_protobuf_helper TEST_OPTION=r TEST_CASE=results
# make test_protobuf_helper TEST_OPTION=l TEST_CASE=outputs/default/queue/

stub: 
	@echo ""

test_protobuf_helper: $(PROTOBUF_HELPER) stub
	@if [ "$(TEST_OPTION)" = "" ]; then\
		echo "Please Set TEST_OPTION Env"; \
		exit 1;\
	fi
	@if [ "$(TEST_CASE)" = "" ]; then\
		echo "Please Set TEST_CASE Env"; \
		exit 1;\
	fi
	@echo "Building test..."
	$(CXX) -DTEST_MUTATE_TIMES=$(TEST_MUTATE_TIMES) -I $(PROTOBUF_SRC_DIR)/include $(PROTOBUF_HELPER) $(PROTOBUF_HELPER_TEST_SRC) -o $(PROTOBUF_HELPER_TEST)
	LD_LIBRARY_PATH=$(shell pwd) ./$(PROTOBUF_HELPER_TEST) $(TEST_OPTION) $(TEST_CASE)

# -DBUILD_SHARED_LIBS=ON; 
# build LPM module
lpm:
	@echo " "
	@cd $(LPM_SRC_DIR); \
	rm -rf build; \
	mkdir build; \
	cd build; \
	cmake .. -GNinja -DCMAKE_C_COMPILER=$(CC) -DCMAKE_CXX_COMPILER=$(CXX) -DCMAKE_BUILD_TYPE=Debug -DLIB_PROTO_MUTATOR_DOWNLOAD_PROTOBUF=ON -DCMAKE_C_FLAGS="-fPIC" -DCMAKE_CXX_FLAGS="-fPIC"; \
	ninja; \
	ninja install

# build hook module
hook: $(HOOK_SRC)
	@echo " "
	@$(CC) $(CFLAG_ARCH) -shared -fPIC -DCALL_FUZZ_FUNC $(HOOK_SRC) -o $(shell pwd)/lib/$(FUZZ_ARCH)/$(HOOK)

# just compile harness
compile: $(HARNESS_SRC)
	@echo " "
	@$(CC) $(CFLAGS) -DCALL_FUZZ_FUNC $(HARNESS_SRC) -o $(HARNESS)


# directly run harness for testing
test: 
	@echo " "
	@$(CC) $(CFLAGS) -DTEST_FUZZ_FUNC $(HARNESS_SRC) -o $(HARNESS)
	@export LD_LIBRARY_PATH=$(FUZZ_LIB_LDPATH); \
	export FUZZ_LIB_PATH=$(FUZZ_LIB_PATH); \
	export FUZZ_LIB_FUNC_NAME=$(FUZZ_LIB_FUNC_NAME); \
	./$(HARNESS)

# trace case
trace: compile
	@if [ "$(TRACE_INPUT_CASE)" = "" ]; then\
		echo "Please Set TRACE_INPUT_CASE Env"; \
		exit 1;\
	fi
	@echo " "
	@export LD_LIBRARY_PATH=$(FUZZ_LIB_LDPATH); \
	export FUZZ_LIB_PATH=$(FUZZ_LIB_PATH); \
	export FUZZ_LIB_FUNC_NAME=$(FUZZ_LIB_FUNC_NAME); \
	afl-qemu-trace $(HARNESS) < $(TRACE_INPUT_CASE)

# directly run harness
dry: compile
	@echo " "
	@export LD_LIBRARY_PATH=$(FUZZ_LIB_LDPATH); \
	export FUZZ_LIB_PATH=$(FUZZ_LIB_PATH); \
	export FUZZ_LIB_FUNC_NAME=$(FUZZ_LIB_FUNC_NAME); \
	./$(HARNESS)

# gdb attach to harness
gdb:
	@echo " "
	@export LD_LIBRARY_PATH=$(FUZZ_LIB_LDPATH); \
	export FUZZ_LIB_PATH=$(FUZZ_LIB_PATH); \
	export FUZZ_LIB_FUNC_NAME=$(FUZZ_LIB_FUNC_NAME); \
	gdb ./$(HARNESS)

# clean
clean:
	rm -rf $(HARNESS)
	rm -rf $(AFL_OUTPUTS)/*
	rm -rf $(PROTOBUF_HELPER) $(PROTOBUF_FUZZ_DATA_CPP) $(PROTOBUF_HELPER_TEST)
	rm -rf *.o 
