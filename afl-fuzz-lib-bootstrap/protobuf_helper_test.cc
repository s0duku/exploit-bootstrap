
#include "protobuf_helper.h"
#include "protobuf_fuzz_data.pb.h"

#include <sstream>
#include <fstream>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <iostream>


size_t mutate_case(void * mutator,std::fstream *fd,uint8_t **out,size_t out_max_size){
    std::stringstream data_buf;
    data_buf << fd->rdbuf();
    std::string data = data_buf.str();
    size_t mutated_size = 0;
    uint8_t *buf = NULL;
    mutated_size = afl_custom_fuzz(mutator,(uint8_t *)data.c_str(),data.size(),&buf,NULL,0,out_max_size);
    mutated_size = protobuf_to_fuzz_input(buf,mutated_size,out);
    free(buf);
    return mutated_size;
}


int main(int argc, char **argv) {

    void *mutator = NULL;
    uint8_t *buf = NULL;
    size_t mutated_size = 0;
    ProtobufFuzzData input;
    std::stringstream data_buf;
    
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << "[r|w] <input_file>" << std::endl;
        return 1;
    }

    if (argv[1][0] == 'w'){
        ProtobufFuzzData payload;
        payload.set_str("json string");
        std::fstream output(argv[2], std::ios::out | std::ios::trunc | std::ios::binary);
    if (!output) {
        std::cout << argv[2] << ": File not found." << std::endl;
        return -1;
    }

    if (!payload.SerializeToOstream(&output)) {
        std::cerr << argv[2] << ": Failed to serialize." << std::endl;
        return -1;
    }

    }else if(argv[1][0] == 'r'){
        std::fstream testfd(argv[2], std::ios::in | std::ios::binary);
        if (!testfd) {
            std::cerr << argv[2] << ": File not found." << std::endl;
            return -1;
        }
        mutator = afl_custom_init(NULL,time(NULL));
        size_t mtimes = 0;
        #ifdef TEST_MUTATE_TIMES
        while (mtimes < TEST_MUTATE_TIMES)
        #else
        while (mtimes < 10)
        #endif
        {
            std::fstream fd(argv[2], std::ios::in | std::ios::binary);
            mutate_case(mutator,&fd,&buf,0x1000);
            std::cout << buf << std::endl;
            free(buf);
            fd.close();
            mtimes++;
        }
        afl_custom_deinit(mutator);
    }else if(argv[1][0] == 'l'){
        // open dir with opendir
        DIR *dir = opendir(argv[2]);
        if(dir == NULL){
            std::cerr << "Error opening directory" << std::endl;
            return -1;
        }

        struct dirent *direntp;
        
        while((direntp=readdir(dir))!=NULL){
            char dirbuf[1024]; 
		    memset(dirbuf,0,sizeof(dirbuf)); 
		    strcpy(dirbuf,argv[2]); 
		    strcat(dirbuf,"/"); 
            strcat(dirbuf,direntp->d_name);
            struct stat statbuf;
            if(stat(dirbuf,&statbuf)==-1){
                std::cerr << "Error stat" << std::endl;
                return -1;
            }
            if(S_ISDIR(statbuf.st_mode)){
                continue;
            }
            ProtobufFuzzData payload;
            std::fstream fd(dirbuf, std::ios::in | std::ios::binary);
            std::stringstream byte_buf;
            byte_buf << fd.rdbuf();
            uint8_t *out = NULL;
            protobuf_to_fuzz_input((uint8_t *)byte_buf.str().c_str(),byte_buf.str().size(),&out);
            if (!out){
                std::cout << "Parse Payload Failed !" << std::endl;
            }else{
                std::cout << out << std::endl;
                free(out);
            }
        }
    }else{
        std::cerr << argv[0] << ": Option unkown." << std::endl;
        return -1;
    }

    return 0;
}