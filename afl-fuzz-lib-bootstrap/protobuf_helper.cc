

#include "libprotobuf-mutator-master/src/mutator.h"
#include "protobuf_helper.h"


//https://github.com/bruce30262/libprotobuf-mutator_fuzzing_learning/blob/master/5_libprotobuf_aflpp_custom_mutator_input/lpm_aflpp_custom_mutator_input.cc

#include <iostream>
#include <sstream>
#include <string>


class MyMutator : public protobuf_mutator::Mutator {
};


void protobuf_to_json_helper(std::stringstream *data_buf,const ProtobufFuzzData *value){
    switch (value->value_case()){
        case ProtobufFuzzData::kObj:
            {
                Json_object jobj = value->obj();
                (*data_buf) << "{";
                for (size_t i = 0;i < jobj.entries_size();i++){
                    if (i > 0) (*data_buf) << ", ";
                    Json_key_value_pair pair = jobj.entries(i);
                    (*data_buf) << "\"";
                    (*data_buf) << pair.key();
                    (*data_buf) << "\": ";
                    if(pair.has_value())
                        protobuf_to_json_helper(data_buf,&pair.value());
                    else
                        (*data_buf) << "\"\"";
                }
                (*data_buf) << "}";
                break;
            }
        case ProtobufFuzzData::kArr:
            {
                Json_array jarr = value ->arr();
                (*data_buf) << "[";
                for (size_t i = 0;i < jarr.values_size();i++){
                    if (i > 0) (*data_buf) << ", ";
                    protobuf_to_json_helper(data_buf,&(jarr.values(i)));
                }
                (*data_buf) << "]";
                break;
            }
        case ProtobufFuzzData::kNum:
            {
                Json_number jn = value->num();
                switch (jn.value_case()){
                    case Json_number::kDouble:
                        (*data_buf) << jn.double_();
                        break;
                    case Json_number::kLong:
                        (*data_buf) << jn.long_();
                        break;
                    default:
                        break;
                }
                break;
            }
        case ProtobufFuzzData::kStr:
            {
                std::string jstr = value->str();
                (*data_buf) << jstr;
                break;
            }
        case ProtobufFuzzData::kTrue:
            (*data_buf) << "true";
            break;
        case ProtobufFuzzData::kFalse:
            (*data_buf) << "false";
            break;
        case ProtobufFuzzData::kNull:
            (*data_buf) << "null";
            break;
        case ProtobufFuzzData::VALUE_NOT_SET:
            (*data_buf) << "null";
            break;
        default:
            // should never execute
            (*data_buf) << "null";
            break;
    }
    return;
}

// example for json
std::string ProtobufToData(const ProtobufFuzzData &protobuf_fuzz_data){
    std::stringstream data_buf;
    protobuf_to_json_helper(&data_buf,&protobuf_fuzz_data);
    std::string data = data_buf.str();
    return data;
}



/**
 * Initialize this custom mutator
 *
 * @param[in] afl a pointer to the internal state object. Can be ignored for
 * now.
 * @param[in] seed A seed for this mutator - the same seed should always mutate
 * in the same way.
 * @return Pointer to the data object this custom mutator instance should use.
 *         There may be multiple instances of this mutator in one afl-fuzz run!
 *         Return NULL on error.
 */
extern "C" void *afl_custom_init(void *afl, unsigned int seed) {
    MyMutator *mutator = new MyMutator();
    
    // mutator->RegisterPostProcessor(
    //     TEST::descriptor(),
    //     [](google::protobuf::Message* message, unsigned int seed) {
    //         // libprotobuf-mutator's built-in mutator is kind of....crappy :P
    //         // Even a dumb fuzz like `TEST.a = rand();` is better in this case... Q_Q
    //         // We register a post processor to apply our dumb fuzz
            
    //         TEST *t = static_cast<TEST *>(message);
    //         t->set_a(rand());
    //     });
    srand(seed);
    return (void *)mutator;
}

/**
 * Perform custom mutations on a given input
 *
 * @param[in] data pointer returned in afl_custom_init for this fuzz case
 * @param[in] buf Pointer to input data to be mutated
 * @param[in] buf_size Size of input data
 * @param[out] out_buf the buffer we will work on. we can reuse *buf. NULL on
 * error.
 * @param[in] add_buf Buffer containing the additional test case
 * @param[in] add_buf_size Size of the additional test case
 * @param[in] max_size Maximum size of the mutated output. The mutation must not
 *     produce data larger than max_size.
 * @return Size of the mutated output.
 */
extern "C" size_t afl_custom_fuzz(void *mutator, // return value from afl_custom_init
                       uint8_t *buf, size_t buf_size, // input data to be mutated
                       uint8_t **out_buf, // output buffer
                       uint8_t *add_buf, size_t add_buf_size,  // add_buf can be NULL
                       size_t max_size) {
    // This function can be named either "afl_custom_fuzz" or "afl_custom_mutator"
    // A simple test shows that "buf" will be the content of the current test case
    // "add_buf" will be the next test case ( from AFL++'s input queue )
    
    ProtobufFuzzData input;
    // parse input data to ProtobufFuzzData
    // Notice that input data should be a serialized protobuf data
    bool parse_ok = input.ParseFromArray(buf, buf_size);
    if(!parse_ok) {
        // Invalid serialize protobuf data. Don't mutate.
        // Return a dummy buffer. Also mutated_size = 0
        static uint8_t *dummy = new uint8_t[10]; // dummy buffer with no data
        *out_buf = dummy;
        return 0;
    }

    // mutate the protobuf
    ((MyMutator *)mutator)->Mutate(&input, max_size);
    
    // Convert protobuf to raw data
    const ProtobufFuzzData *p = &input;
    std::string s = ProtobufToData(*p);
    // Copy to a new buffer ( mutated_out )
    size_t mutated_size = s.size() <= max_size ? s.size() : max_size; // check if raw data's size is larger than max_size
    // becareful memory leak
    uint8_t *mutated_out = new uint8_t[mutated_size+1];
    memcpy(mutated_out, s.c_str(), mutated_size); // copy the mutated data
    mutated_out[mutated_size] = 0;
    // Assign the mutated data and return mutated_size
    *out_buf = mutated_out;
    return mutated_size;
}

/**
 * Deinitialize everything
 *
 * @param data The data ptr from afl_custom_init
 */
extern "C" void afl_custom_deinit(void *data) {
    // Honestly I don't know what I'm gonna do with this...
    return;
}